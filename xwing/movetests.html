<!DOCTYPE html>
<html>
<head>
<script src="https://code.jquery.com/jquery-3.0.0.min.js" integrity="sha256-JmvOoLtYsmqlsWxa7mDSLMwa6dZ9rrIdtrrVYRnDRH0=" crossorigin="anonymous"></script>
<script>

	$(document).ready( function () {
		var c = document.getElementById("playmat");
		var ctx = c.getContext("2d");
		
	// Ship and Turn info
		var SHIPS = [
			{"posX":0,"posY":0,"rotation":0,"size":80},
			{"posX":0,"posY":0,"rotation":0,"size":160}
		];
		var ship;	// Ship data
		var RADII = {"T":[70,126,180],"B":[160,260,360]};
		var rad;		// Turn Radius
		var adjRad;	// Adjust for Left Turn
		var ANGLES = {"T":Math.PI/2,"B":Math.PI/4};
		var ang; 	// Turn Angle
		var adjAng;	// Adjust for Left Turn
		var oldA;
		var oldB;
		var oldC;
		
	// INPUT VARIABLES
		var ORIG = {"x":500,"y":500};
		var r = 0;
		
		var shipid = 1;
		var speed = 3;
		var type = 'B';
		var dir = 'L';
	
	// Initialise
		rad = RADII[type][speed-1];
		adjRad = rad * (dir == 'L' ? -1 : 1);
		ang = ANGLES[type];
		adjAng = ang * (dir == 'L' ? -1 : 1);
		
		if (dir == 'L') {ORIG.x -= rad;}
		
		ship = SHIPS[shipid];
		ship.posX = ORIG.x - adjRad - ship.size/2;
		ship.posY = ORIG.y ;
		ship.rotation = 0;
		
		oldA = {"x":ship.posX + ship.size/2,"y":ship.posY};
		oldB = {"x":oldA.x,"y":ship.posY + ship.size};
		oldC = {"x":oldA.x,"y":ship.posY + ship.size/2};
		
	// Isoceles
		if (rad * 2 > ship.size) {
			var angBase = Math.acos( (ship.size/2) / rad) ;
			var angIso = Math.PI - (2 * angBase);
			console.log ('Isoceles - Base:' + angBase.toDegrees() + 'deg Top:' + angIso.toDegrees() + 'deg');
		} else {
			angIso = -1;
			console.log ('Isoceles: Ship too large');
		}
		
		refreshMat();
		
		function refreshMat() {
			ctx.clearRect(0,0,1000,1000);
			drawTrack();
			drawShip(ship);
		}	
		
		function moveShip(ship, inc)	{
		// Variables
			var newA;
			var newB;
			var newC;
			
			var rRads;		// Angle in radians
			var d = dir == 'L' ? -1 : 1;
						
			r = Math.min(r + inc,170);			
			rRads = r.toRadians();
			
		// TO DO - STOP BEFORE 170
			
		// Locate newA.x and newA.y
			newA = {"x":0,"y":0};
			
			if (r>0 && r<=ang.toDegrees())	{	// On curve
				newA.x = oldA.x + adjRad - (adjRad * Math.cos(rRads));
				newA.y = oldA.y - (rad * Math.sin(rRads));
			} else {										// Off curve
				// Final Curve position
				newA.x = oldA.x + adjRad - (adjRad * Math.cos(ang));
				newA.y = oldA.y - (rad * Math.sin(ang));
				// Calculate Tangent
				var tTan = Math.min(rad * Math.tan(rRads - ang),ship.size);
				
				// reverse engineer angle based on capped tTan
				console.log('rRads:' + rRads.toDegrees());
				rRads = Math.atan(tTan/rad) + ang;
				console.log('revised rRads:' + rRads.toDegrees());
				
				// Plus calculate x,y from Tangent
				newA.x += tTan * Math.cos(Math.PI/2 - ang) * d;
				newA.y -= tTan * Math.sin(Math.PI/2 - ang);
			}
			// Log Results
			console.log ("oldA x,y: " + oldA.x + "," + oldA.y);
			console.log ("newA x,y: " + newA.x + "," + newA.y);
			drawPoint (newA,"#FF0000");
		
		// Locate newB.x and newB.y
			newB = {"x":0,"y":0};
			
			var i = Math.sqrt( Math.pow(newA.x-oldA.x,2) + Math.pow(oldA.y-newA.y,2) );
			if (i > ship.size) {
				// Find newB.x and newB.y from intersection of two arcs
				// Side a = Ship.size (opp angle a)
				// Side b = ORIG(x,y) -> newA(x,y) (opp angle b)
				// Side c = rad (opp angle c)
				
				var sA = ship.size;
				var sB = Math.sqrt( Math.pow(newA.x-ORIG.x,2) + Math.pow(ORIG.y-newA.y,2) );
				var sC = rad;
				
				console.log('Scalene - A:' + sA + ' B:' + sB + ' C:' + sC);
				
				// Law of cosines
				var angA = Math.acos( ( Math.pow(sB,2) + Math.pow(sC,2) - Math.pow(sA,2) ) / (2 * sB * sC) );
				var angnewB = rRads - angA;
				newB.x = oldA.x + adjRad - (adjRad * Math.cos(angnewB));
				newB.y = oldA.y - (rad * Math.sin(angnewB));
				
			} else {
				// Fixed newB.x, Triangulate newB.y
				newB.x = oldB.x;
				newB.y = newA.y + Math.sqrt( Math.pow(ship.size,2) - Math.pow(newA.x-newB.x,2) );
			}
			// Log Results
			console.log ("oldB x,y: " + oldB.x + "," + oldB.y);
			console.log ("newB x,y: " + newB.x + "," + newB.y);
			drawPoint(newB,"#0000FF");
			
			/*
			// Draw
			ctx.beginPath();
			ctx.moveTo(ORIG.x,ORIG.y);
			ctx.lineTo(newA.x,newA.y);
			ctx.lineTo(newB.x,newB.y);
			ctx.lineTo(ORIG.x,ORIG.y);
			ctx.stroke();
			*/
			// Locate middle of Ship and move Ship
			newC = {"x":0,"y":0};
			newC.x = newB.x + (newA.x - newB.x)/2;
			newC.y = newB.y - (newB.y - newA.y)/2;
			
			ship.posX = newC.x - ship.size/2;
			ship.posY = newC.y - ship.size/2;
			
			// TURN?
			ship.rotation = 90 - (Math.acos(Math.min((newA.x-newB.x)/ship.size,1)) * 180 / Math.PI);
			
		}
		
		function drawPoint(pos,clr) {
			ctx.strokeStyle = clr;
			ctx.setTransform(1,0,0,1,0,0);
			ctx.beginPath();
			ctx.arc(pos.x,pos.y,5,0,Math.PI*2);
			ctx.stroke();
		}
		
		function drawTrack()	{
			ctx.setTransform(1,0,0,1,0,0);
			ctx.strokeStyle = "#AAA";
			
			ctx.beginPath();
			ctx.rect(ORIG.x-adjRad-20,ORIG.y,40,ship.size);
			ctx.moveTo(ORIG.x-adjRad,ORIG.y);
			ctx.lineTo(ORIG.x-adjRad,ORIG.y+ship.size);
			ctx.stroke();
			
			var arc = {"start":0,"end":0};
			
			if (dir == 'L')	{
				arc.start = Math.PI*2 - ang;
				arc.end = 0;
			} else {	//assume 'R'
				arc.start = Math.PI;
				arc.end = Math.PI + ang;
			}
			
			ctx.beginPath();
			ctx.arc(ORIG.x, ORIG.y, rad, arc.start, arc.end);
			ctx.stroke();
			
			ctx.beginPath();
			ctx.arc(ORIG.x, ORIG.y, rad-20,arc.start, arc.end);
			ctx.stroke();
			
			ctx.beginPath();
			ctx.arc(ORIG.x, ORIG.y, rad+20, arc.start, arc.end);
			ctx.stroke();
						
			ctx.beginPath();
			/*if (ang == Math.PI/2) {		// 90 deg
				ctx.rect(ORIG,ORIG-rad-20,ship.size,40);
				ctx.moveTo(ORIG,ORIG-rad);
				ctx.lineTo(ORIG+ship.size,ORIG-rad);
			}	else {						// 45 deg*/
				ctx.moveTo(ORIG.x-((adjRad+20)*Math.cos(adjAng)),ORIG.y-((adjRad+20)*Math.sin(adjAng)));
				ctx.lineTo(ORIG.x-((adjRad-20)*Math.cos(adjAng)),ORIG.y-((adjRad-20)*Math.sin(adjAng)));
				
				ctx.lineTo(ORIG.x-((adjRad-20)*Math.cos(adjAng))+(ship.size*Math.cos(Math.PI/2 - adjAng)),ORIG.y-((adjRad-20)*Math.sin(adjAng))-(ship.size*Math.sin(Math.PI/2 - adjAng)));
				ctx.lineTo(ORIG.x-((adjRad+20)*Math.cos(adjAng))+(ship.size*Math.cos(Math.PI/2 - adjAng)),ORIG.y-((adjRad+20)*Math.sin(adjAng))-(ship.size*Math.sin(Math.PI/2 - adjAng)));	
				ctx.lineTo(ORIG.x-((adjRad+20)*Math.cos(adjAng)),ORIG.y-((adjRad+20)*Math.sin(adjAng)));				
				ctx.moveTo(ORIG.x-(adjRad*Math.cos(adjAng)),ORIG.y-(adjRad*Math.sin(adjAng)));
				ctx.lineTo(ORIG.x-(adjRad*Math.cos(adjAng))+(ship.size*Math.cos(Math.PI/2 - adjAng)),ORIG.y-(adjRad*Math.sin(adjAng))-(ship.size*Math.sin(Math.PI/2 - adjAng)));	
			//}
			ctx.stroke();
			
		}
		
		function drawShip(ship)	{
			
			ctx.strokeStyle = "#00FF00";
			ctx.beginPath();
			
		/* Set the relative location */
			ctx.setTransform(1,0,0,1,0,0)
			ctx.translate(ship.posX,ship.posY);
			
		/* Locate ship center and rotate */
			ctx.translate (ship.size/2,ship.size/2);
			ctx.rotate(ship.rotation*Math.PI/180);
			ctx.translate (-ship.size/2,-ship.size/2);
		
		/* Draw Ship */
			ctx.rect(0,0,ship.size,ship.size);
			
			ctx.moveTo(ship.size/2,0);
			ctx.lineTo(ship.size/2,ship.size);
			
			ctx.moveTo(0,ship.size/2);
			ctx.lineTo(ship.size,ship.size/2);
			ctx.stroke();
			
		/* Draw Arrow */
			ctx.beginPath();
			ctx.moveTo (ship.size/2,2);
			ctx.lineTo (ship.size/2 + 5,7);
			ctx.lineTo (ship.size/2 + 3,7);
			ctx.lineTo (ship.size/2,4);
			ctx.lineTo (ship.size/2 - 3,7);
			ctx.lineTo (ship.size/2 - 5,7);
			ctx.lineTo (ship.size/2 - 5,7);
			ctx.lineTo (ship.size/2,2);
			ctx.fillStyle = "#00FF00";
			ctx.fill();
		}
		
		$("#playmat").on("click",function() {
			moveShip(ship,10);
			refreshMat();
		});
		
	});
	
	Number.prototype.toDegrees = function () {
		return this.valueOf() * 180 / Math.PI;
	}
	Number.prototype.toRadians = function () {
		return this.valueOf() * Math.PI / 180;
	}
</script>
</head>
<body>
	<canvas id="playmat" width="1000" height="1000"></canvas>
</body>
</html>